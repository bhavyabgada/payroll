config {
  type: "incremental",
  schema: "{{ dataset_id or 'warehouse' }}",
  name: "{{ dimension_name }}",
  {%- if partition_by %}
  bigquery: {
    partitionBy: "{{ partition_by }}",
    {%- if cluster_by %}
    clusterBy: {{ cluster_by | tojson }},
    {%- endif %}
  },
  {%- endif %}
  tags: ["scd2", "dimension"],
  description: "SCD Type 2 dimension generated by scd2-bq-engine"
}

-- SCD Type 2 Dimension: {{ dimension_name }}
-- Generated by: scd2-bq-engine v0.1.0
-- Business Keys: {{ business_keys | join(', ') }}
-- Tracked Columns: {{ tracked_columns | join(', ') }}

WITH source_data AS (
  SELECT
    -- Business keys
    {%- for key in business_keys %}
    {{ key }},
    {%- endfor %}
    
    -- Tracked columns
    {%- for col in tracked_columns %}
    {{ col }},
    {%- endfor %}
    
    -- Hash for change detection
    {{ hash_algorithm | upper }}(
      CONCAT(
        {%- for col in tracked_columns %}
        COALESCE(CAST({{ col }} AS STRING), ''),
        {%- if not loop.last %}'|',{% endif %}
        {%- endfor %}
      )
    ) AS {{ hash_col }},
    
    -- Metadata columns
    {%- for col in meta_columns %}
    {{ col }},
    {%- endfor %}
    
    -- Effective date (use load timestamp or provided date)
    CURRENT_TIMESTAMP() AS load_timestamp
  
  FROM {{ source_table }}
  WHERE TRUE
    -- Incremental load filter (uncomment in Dataform)
    -- AND DATE(updated_at) >= DATE('${dataform.projectConfig.vars.incremental_date}')
),

{%- if soft_delete %}
-- Detect soft deletes (records in target but not in source)
deleted_records AS (
  SELECT
    target.{{ surrogate_key_name }},
    target.{{ effective_from_col }},
    CURRENT_TIMESTAMP() AS {{ effective_to_col }},
    FALSE AS {{ is_current_col }}
  FROM ${ref("{{ dimension_name }}")} target
  LEFT JOIN source_data source
    ON {% for key in business_keys %}target.{{ key }} = source.{{ key }}{% if not loop.last %} AND {% endif %}{% endfor %}
  WHERE source.{{ business_keys[0] }} IS NULL
    AND target.{{ is_current_col }} = TRUE
),
{%- endif %}

-- Detect new and changed records
changes AS (
  SELECT
    source.*,
    target.{{ surrogate_key_name }},
    target.{{ effective_from_col }} AS target_effective_from,
    target.{{ hash_col }} AS target_hash,
    CASE
      WHEN target.{{ surrogate_key_name }} IS NULL THEN 'INSERT'
      WHEN target.{{ hash_col }} != source.{{ hash_col }} THEN 'UPDATE'
      ELSE 'NO_CHANGE'
    END AS change_type
  
  FROM source_data source
  LEFT JOIN ${ref("{{ dimension_name }}")} target
    ON {% for key in business_keys %}source.{{ key }} = target.{{ key }}{% if not loop.last %} AND {% endif %}{% endfor %}
    AND target.{{ is_current_col }} = TRUE
)

{%- if handle_late_arrivals %}
-- Handle late-arriving dimensions
-- TODO: Implement late arrival logic
{%- endif %}

-- Generate output with surrogate keys
SELECT
  -- Surrogate key (generate for new records)
  CASE
    WHEN change_type = 'INSERT' THEN GENERATE_UUID()
    ELSE {{ surrogate_key_name }}
  END AS {{ surrogate_key_name }},
  
  -- Business keys
  {%- for key in business_keys %}
  {{ key }},
  {%- endfor %}
  
  -- Tracked columns
  {%- for col in tracked_columns %}
  {{ col }},
  {%- endfor %}
  
  -- SCD2 columns
  {{ hash_col }},
  CASE
    WHEN change_type = 'INSERT' THEN load_timestamp
    WHEN change_type = 'UPDATE' THEN load_timestamp
    ELSE target_effective_from
  END AS {{ effective_from_col }},
  
  CASE
    WHEN change_type IN ('INSERT', 'NO_CHANGE') THEN TIMESTAMP('9999-12-31 23:59:59')
    ELSE load_timestamp
  END AS {{ effective_to_col }},
  
  CASE
    WHEN change_type IN ('INSERT', 'NO_CHANGE') THEN TRUE
    ELSE FALSE
  END AS {{ is_current_col }},
  
  -- Metadata
  {%- for col in meta_columns %}
  {{ col }},
  {%- endfor %}
  load_timestamp AS _loaded_at

FROM changes
WHERE change_type != 'NO_CHANGE'

{%- if soft_delete %}
UNION ALL

-- Add deleted records
SELECT
  {{ surrogate_key_name }},
  {%- for key in business_keys %}
  target.{{ key }},
  {%- endfor %}
  {%- for col in tracked_columns %}
  target.{{ col }},
  {%- endfor %}
  target.{{ hash_col }},
  target.{{ effective_from_col }},
  deleted_records.{{ effective_to_col }},
  deleted_records.{{ is_current_col }},
  {%- for col in meta_columns %}
  target.{{ col }},
  {%- endfor %}
  CURRENT_TIMESTAMP() AS _loaded_at
FROM deleted_records
JOIN ${ref("{{ dimension_name }}")} target
  ON deleted_records.{{ surrogate_key_name }} = target.{{ surrogate_key_name }}
  AND deleted_records.{{ effective_from_col }} = target.{{ effective_from_col }}
{%- endif %}

-- Close out old records for updates
UNION ALL

SELECT
  {{ surrogate_key_name }},
  {%- for key in business_keys %}
  target.{{ key }},
  {%- endfor %}
  {%- for col in tracked_columns %}
  target.{{ col }},
  {%- endfor %}
  target.{{ hash_col }},
  target.{{ effective_from_col }},
  changes.load_timestamp AS {{ effective_to_col }},
  FALSE AS {{ is_current_col }},
  {%- for col in meta_columns %}
  target.{{ col }},
  {%- endfor %}
  CURRENT_TIMESTAMP() AS _loaded_at
FROM changes
JOIN ${ref("{{ dimension_name }}")} target
  ON {% for key in business_keys %}changes.{{ key }} = target.{{ key }}{% if not loop.last %} AND {% endif %}{% endfor %}
  AND target.{{ is_current_col }} = TRUE
WHERE changes.change_type = 'UPDATE'

