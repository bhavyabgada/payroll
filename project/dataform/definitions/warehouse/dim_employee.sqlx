config {
  type: "incremental",
  schema: "payroll_warehouse",
  name: "dim_employee",  bigquery: {
    partitionBy: "effective_from",    clusterBy: ["employee_id", "is_current", "department"],  },  tags: ["scd2", "dimension"],
  description: "SCD Type 2 dimension generated by scd2-bq-engine"
}

-- SCD Type 2 Dimension: dim_employee
-- Generated by: scd2-bq-engine v0.1.0
-- Business Keys: employee_id
-- Tracked Columns: first_name, last_name, email, phone, job_id, department, status

WITH source_data AS (
  SELECT
    -- Business keys    employee_id,    
    -- Tracked columns    first_name,    last_name,    email,    phone,    job_id,    department,    status,    
    -- Hash for change detection
    MD5(
      CONCAT(        COALESCE(CAST(first_name AS STRING), ''),'|',        COALESCE(CAST(last_name AS STRING), ''),'|',        COALESCE(CAST(email AS STRING), ''),'|',        COALESCE(CAST(phone AS STRING), ''),'|',        COALESCE(CAST(job_id AS STRING), ''),'|',        COALESCE(CAST(department AS STRING), ''),'|',        COALESCE(CAST(status AS STRING), ''),      )
    ) AS row_hash,
    
    -- Metadata columns    hire_date,    termination_date,    created_at,    updated_at,    
    -- Effective date (use load timestamp or provided date)
    CURRENT_TIMESTAMP() AS load_timestamp
  
  FROM ${ref('stg_employees')}
  WHERE TRUE
    -- Incremental load filter (uncomment in Dataform)
    -- AND DATE(updated_at) >= DATE('${dataform.projectConfig.vars.incremental_date}')
),-- Detect soft deletes (records in target but not in source)
deleted_records AS (
  SELECT
    target.employee_key,
    target.effective_from,
    CURRENT_TIMESTAMP() AS effective_to,
    FALSE AS is_current
  FROM ${ref("dim_employee")} target
  LEFT JOIN source_data source
    ON target.employee_id = source.employee_id  WHERE source.employee_id IS NULL
    AND target.is_current = TRUE
),
-- Detect new and changed records
changes AS (
  SELECT
    source.*,
    target.employee_key,
    target.effective_from AS target_effective_from,
    target.row_hash AS target_hash,
    CASE
      WHEN target.employee_key IS NULL THEN 'INSERT'
      WHEN target.row_hash != source.row_hash THEN 'UPDATE'
      ELSE 'NO_CHANGE'
    END AS change_type
  
  FROM source_data source
  LEFT JOIN ${ref("dim_employee")} target
    ON source.employee_id = target.employee_id    AND target.is_current = TRUE
)-- Handle late-arriving dimensions
-- TODO: Implement late arrival logic
-- Generate output with surrogate keys
SELECT
  -- Surrogate key (generate for new records)
  CASE
    WHEN change_type = 'INSERT' THEN GENERATE_UUID()
    ELSE employee_key
  END AS employee_key,
  
  -- Business keys  employee_id,  
  -- Tracked columns  first_name,  last_name,  email,  phone,  job_id,  department,  status,  
  -- SCD2 columns
  row_hash,
  CASE
    WHEN change_type = 'INSERT' THEN load_timestamp
    WHEN change_type = 'UPDATE' THEN load_timestamp
    ELSE target_effective_from
  END AS effective_from,
  
  CASE
    WHEN change_type IN ('INSERT', 'NO_CHANGE') THEN TIMESTAMP('9999-12-31 23:59:59')
    ELSE load_timestamp
  END AS effective_to,
  
  CASE
    WHEN change_type IN ('INSERT', 'NO_CHANGE') THEN TRUE
    ELSE FALSE
  END AS is_current,
  
  -- Metadata  hire_date,  termination_date,  created_at,  updated_at,  load_timestamp AS _loaded_at

FROM changes
WHERE change_type != 'NO_CHANGE'UNION ALL

-- Add deleted records
SELECT
  employee_key,  target.employee_id,  target.first_name,  target.last_name,  target.email,  target.phone,  target.job_id,  target.department,  target.status,  target.row_hash,
  target.effective_from,
  deleted_records.effective_to,
  deleted_records.is_current,  target.hire_date,  target.termination_date,  target.created_at,  target.updated_at,  CURRENT_TIMESTAMP() AS _loaded_at
FROM deleted_records
JOIN ${ref("dim_employee")} target
  ON deleted_records.employee_key = target.employee_key
  AND deleted_records.effective_from = target.effective_from
-- Close out old records for updates
UNION ALL

SELECT
  employee_key,  target.employee_id,  target.first_name,  target.last_name,  target.email,  target.phone,  target.job_id,  target.department,  target.status,  target.row_hash,
  target.effective_from,
  changes.load_timestamp AS effective_to,
  FALSE AS is_current,  target.hire_date,  target.termination_date,  target.created_at,  target.updated_at,  CURRENT_TIMESTAMP() AS _loaded_at
FROM changes
JOIN ${ref("dim_employee")} target
  ON changes.employee_id = target.employee_id  AND target.is_current = TRUE
WHERE changes.change_type = 'UPDATE'
